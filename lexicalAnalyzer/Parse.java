package lexicalAnalyzer;

import java.io.File;
import java.io.IOException;
import java.util.Scanner;

/*
 * Parser
 * Alexander Cromer
 * CSCI 4200
 * Dr. Abi Salimi
 * A lexical analyzer that we worked on for Programming Languages
 */

public class Parse {

	static int charClass;
	static char[] lexeme = new char[100];
	static char nextChar;
	static int lexLen;
	static int token;
	static int nextToken;
	static final int LETTER = 0;
	static final int DIGIT = 1;
	static final int UNKNOWN = 99;
	static final char EOF = '#';
	static int INT_LIT = 10;
	static int IDENT = 11;
	static int ASSIGN_OP = 20;
	static int ADD_OP = 21;
	static int SUB_OP = 22;
	static int MULT_OP = 23;
	static int DIV_OP = 24;
	static int LEFT_PAREN = 25;
	static int RIGHT_PAREN = 26;

	static Scanner Scan = new Scanner(System.in);

	static String line = "";
	static boolean end = true;

	public static void main(String[] args) throws IOException {
		// reads a text file, returns an error message if the file is missing
		try {
			Scan = new Scanner(new File("src\\parserPackage\\statements.txt"));
		} catch (IOException e) {
			System.out.println(
					"file not found. The file should be placed in the java folder with the java program, src\\parserPackage\\statements.txt");
		}
		// scans the text file and passes the lines to the lexical analyzer if
		// there is info as well as outputting the expression on the line
		while (Scan.hasNext()) {
			line = Scan.nextLine();
			System.out.println("************************************************");
			System.out.print("Parsing the statement: ");
			System.out.println(line);
			System.out.println();
			line = line + EOF;

			getChar();

			do {

				lex();
				assign();

			} while (nextChar != EOF);

		}

	}

	private static void assign() throws IOException {
		System.out.printf("Enter <assign>\n");
		//only runs if nextToken isn't EOF
		while (nextToken != 65535) {

			lex();
			//runs if nextToken isn't an assignment operation
			if (nextToken != 20) {
				expr();
			}

		}

		System.out.printf("Exit <assign>\n");

	}

	// expression parse strings in the language generated by the rule
	public static void expr() throws IOException {

		System.out.printf("Enter <expr>\n");

		// parse first term
		term();

		// as long as the next token is + or -. get the next token and parse the
		// next term
		while (nextToken == ADD_OP || nextToken == SUB_OP) {
			lex();
			term();
		}
		System.out.printf("Exit <expr>\n");
	} // end of function expr

	// public static void assign()P
	// term parses strings in the language generated by the rule <term> ->
	// <factor> {(* | /)
	public static void term() throws IOException {
		System.out.printf("Enter <term>\n");

		// parse the first factor
		factor();

		// as long as the next token is * or /, get the next token and parse the
		// next factor */
		while (nextToken == MULT_OP || nextToken == DIV_OP) {
			lex();
			factor();
		}
		System.out.printf("Exit <term>\n");
	} // end of function term

	// Parses strings in the language generated by the rule: <factor> -> id |
	// int_constant | ( <expr)
	public static void factor() throws IOException {
		System.out.printf("Enter <factor>\n");

		if (nextToken == 20) {
			getnonblank();
		} else {
			if (nextToken != EOF) {
				// determines which RHS
				if (nextToken == IDENT || nextToken == INT_LIT) {

					// gets the next token
					lex();

					// If RHS is ( <expr>), call lex to pass over the left
					// parenthesis,
					// call expr, and check for the right parenthesis
				} else {
					if (nextToken == LEFT_PAREN) {
						lex();
						expr();

						if (nextToken == RIGHT_PAREN)
							lex();
						else
							error();
					} // end of if (nextToken == ...

					// It was not an id, an integer literal, or a left
					// parenthesis
					else {
						error();
					} // end of else
				}
			} // End of function factor
			System.out.printf("Exit <factor>\n");
		}
	}

	public static void error() {

		System.out.println("ERROR");

	}

	// looks up the char that was passed and assigns its value to nextToken and
	// adds it to the array
	static int lookup(char ch) {
		switch (ch) {
		case '(':
			addChar();
			nextToken = LEFT_PAREN;
			break;

		case ')':
			addChar();
			nextToken = RIGHT_PAREN;
			break;

		case '+':
			addChar();
			nextToken = ADD_OP;
			break;

		case '-':
			addChar();
			nextToken = SUB_OP;
			break;

		case '*':
			addChar();
			nextToken = MULT_OP;
			break;

		case '/':
			addChar();
			nextToken = DIV_OP;
			break;

		case '=':
			addChar();
			nextToken = ASSIGN_OP;
			break;
		default:
			addChar();
			nextToken = EOF;
			break;
		}
		return nextToken;

	}

	// adds the char value to the lexeme array
	private static void addChar() {
		if (lexLen <= 98) {
			lexeme[lexLen++] = nextChar;
			lexeme[lexLen] = 0;
		} else
			System.out.println("Error- lexeme is too long \n");
	}

	// takes the string passed and substrings the expression to shorten and
	// re-read as well as assigning the read character to either a letter,
	// digit, unknown, or EOF
	public static void getChar() {

		nextChar = line.charAt(0);
		line = line.substring(1);
		// System.out.println((nextChar==EOF) + " " + line);
		if (nextChar != EOF) {

			if (Character.isLetter(nextChar)) {
				charClass = LETTER;
			} else if (Character.isDigit(nextChar)) {
				charClass = DIGIT;
			} else {
				charClass = UNKNOWN;
			}
		} else {
			charClass = EOF;
		}

	}

	// reads a space in the expression
	static void getnonblank() {
		while (nextChar == ' ')
			getChar();
	}

	// lex
	public static int lex() throws IOException {
		lexLen = 0;
		getnonblank();
		switch (charClass) {
		// parse identifiers
		case LETTER:
			addChar();
			getChar();
			while (charClass == LETTER || charClass == DIGIT) {
				addChar();
				getChar();
			}
			nextToken = IDENT;
			break;

		// parse integer literals
		case DIGIT:
			addChar();
			getChar();
			while (charClass == DIGIT) {
				addChar();
				getChar();
			}
			nextToken = INT_LIT;
			break;

		// parenthesis and operators
		case UNKNOWN:
			lookup(nextChar);
			getChar();
			break;

		// EOF
		case EOF:
			nextToken = (char) -1;
			lexeme[0] = 'E';
			lexeme[1] = 'O';
			lexeme[2] = 'F';
			lexeme[3] = 0;
			break;
		} // end of switch

		System.out.println("The next token is: " + nextTokenString() + "\tThe next lexeme is " + toaString());

		return nextToken;
		// end of function lex
	}

	// converts the original integers from the lexical analyzer into a string to be printed for the output
	public static String nextTokenString() {
		String tokenString = "";

		switch (nextToken) {
		case 10:
			tokenString = "INT_LIT";
			break;
		case 11:
			tokenString = "IDENT";
			break;
		case 20:
			tokenString = "EQUALS_OP";
			break;
		case 21:
			tokenString = "ADD_OP";
			break;
		case 22:
			tokenString = "SUB_OP";
			break;
		case 23:
			tokenString = "MULT_OP";
			break;
		case 24:
			tokenString = "DIV_OP";
			break;
		case 25:
			tokenString = "LEFT_PAREN";
			break;
		case 26:
			tokenString = "RIGHT_PAREN";
			break;
		case 65535:
			tokenString = "END_OF_FILE";
			break;
		}
		return tokenString;
	}

	// reads the array and returns the next lexeme to be printed out from lex()
	public static String toaString() {
		String empty = "";
		for (int i = 0; i < lexeme.length; i++) {
			if (lexeme[i] == 0) {
				break;
			}
			empty += lexeme[i];
		}
		return empty;
	}

}
